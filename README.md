Ground Station OSD
==================
This project converts the (Micro) MinimOSD (containing the MAX7456 video chip) into a ground station OSD, displaying obvious information like battery voltage and remaining run time, but also capable of displaying arbitrary information wireless over Bluetooth or over a wired serial connection. In any case, this is a fundamental difference with other OSDs, all data is generated externally and the OSD is only used to display it properly. Ok, some data like sensor voltages are generated by the OSD itself, but displaying it is still under control of the external device that is connected to the serial port. At this moment, data is never cleared except when using the CLEAR command or when overwriting the data with spaces. So when the serial connection is lost or the external device doesn't send any more updates, the current texts remain visible. This may change in the future. Actual implementations are out of scope of this project. But I'm thinking of augmented info like telemetry data or anything that comes from the internet. For FPV pilots it could be handy to have live air-traffic data available in their goggles. Or simply a Twitter feed that warns that the CAA/FAA is coming ... Note that this project isn't necessarily about flying. The first steps were made with a goggle on the street...literally.


Demo
----
Because a short video tells more than all this crap: https://www.youtube.com/watch?v=zLIC-bxLw2U. The script responsible for this can be found in the examples directory. It runs on Linux/Unix but it shouldn't be too hard to understand for anyone with basic shell-programming skills.


Bluetooth
---------
To control the OSD wirelessly, just connect an Arduino compatible BT-module. Manuals can be found online. Note that the MinimOSD isn't aware of any BT-module; it just talks over its serial connection. Baud rates should match between the OSD and BT-module and between the BT-module and the outside. These two baud rates can be different.


Building
--------
This software is written in c/c++ and uses Arduino libraries. Using the Arduino application, just open the GSOSD.ino file and you're good to go. Using Arduino.mk, the Makefile can be found in the sources. Handy commands:
make		- compile & link the software
make upload	- upload binary to OSD
make monitor	- set up serial monitor to OSD


Quick start guide
-----------------
1. Connect the OSD via an FTDI- or alike adapter to your computer.
2. Start the Arduino IDE, choose Board "Arduino Pro or Pro Mini", Processor "ATmega328 5V".
3. Open file GSOSD.ino.
4. Click verify and then upload.
5. Start Serial Monitor with 9600 baud. You should see the GSOSD welcome message.
6. Type "LIST" followed by enter or space. This shows a list of available commands.
7. You can try to print something on the screen, e.g. with command "P_RAW 9 6 12 Hello world!". By default, the text should be visible. If not, try command "RESET" followed by "SET_ENABLE 1".


Font characters
---------------
By default many Micro MinimOSDs come with a small part of the ASCII character set (only numbers and capitals) and some Chinese characters in the higher character range. This doesn't do the job for western folks. A basic ASCII font can be found in the font directory, along with the steps to upload it. If you want a different font, don't mess around with a pixel editor, but take a look at the scripts in the font directory. Using free standard tools and some patience you'll generate any font in no time :-) In any case, you don't need special software to upload/download font characters. Simply use the SET_FONT/GET_FONT commands to handle characters one by one.


Testing & debugging
-------------------
Testing can be done best by using a serial monitor over a wired connection. Arduino has built-in support for this. Using the Makefile, command "make monitor" does the trick. An alternative for this on Linux(-like) systems is to access the serial port directly, e.g. with these commands in two separate shells:

`cat /dev/ttyUSB0`  
`echo ' LIST ' >/dev/ttyUSB0`

This sends the LIST command in one shell and prints the output in another shell. Depending on your hardware, 'ttyUSB0' may be something different. Over a wireless connection it could be something like 'rfcomm0'.  For wireless testing with Windows/Android there are several BT-tools available on the internet. The serial communication doesn't use any handshaking, which means that flooding the serial input buffer is possible and will cause processing errors. Note that Arduino uses a 64 bytes buffer only. But you can always use your own handshaking on top of the existing protocol. See the API for details. Also using a different baud rate could help. But setting it lower also decreases processing speed, so it may not help at all.
The software comes with an API that is human readable, so using text only. Numbers are expressed as text in decimal notation. Binary bits are expressed with '1' and '0'. Non-printable characters in requests are hex-escaped when echoed back.


Calibrating sensors
-------------------
The Micro MinimOSD board is equipped with 4 sensors; labelled "VBAT1", "VBAT2", "RSSI" and "CURR". These should be calibrated before usage. In principle all these sensors measure a voltage. But VBAT1 and VBAT2 are for higher voltages like lipo batteries up to 4s (17V) while RSSI and CURR are for lower voltages (<1.1V). Just like the ranges on a voltmeter. The formula we use is:

V-display = Factor * V-raw * SENSADJ / 1023

where SENSADJ is a configurable integer number between 0 and UINT16_MAX (65535). Factor is a multiplication factor which is 0.001 for VBAT1,VBAT2 and 0.0001 for RSSI,CURR. The value SENSADJ can be configured per sensor. These are the values SENSADJ0, SENSADJ1, SENSADJ2 and SENSADJ3 which can be retrieved with commands GET_SENSADJ* and set with SET_SENSADJ*. Calibrating goes as follows:
- attach a known voltage (V-cal) to any of these sensor pins, e.g. 5.0V for VBAT1/VBAT2 and 1.0V for RSSI/CURR.
- Use command SET_SENSADJ* to set the calibration value (S-cal) somewhere in the middle, say 20000.
- Use command GET_SENSOR * to read the sensor value (V-display).
- Calculate final value S-cal * V-cal / V-display and set it with SET_SENSADJ*.

Example to calibrate VBAT1:
- Attach 5.0V to the pin labelled "VBAT1".
- Open a serial connection to the OSD.
- Type in command "SET_SENSADJ0 20000" \<press enter\>.
- Type in command "GET_SENSOR 0" \<press enter\>.
  => The serial connection returns a value, say "6.20".
  => Final calibration value: 20000 * 5.0 / 6.20 = 16129.
- Type in command "SET_SENSADJ0 16129" \<press enter\>.
- Use command "GET_SENSOR 0" to check whether it returns "5.00" now.
- Save settings with command "SAVE" \<press enter\>.


Example application; battery voltage & remaining run time
---------------------------------------------------------
https://www.youtube.com/watch?v=WCpxvjb2Bmo
We'd like to show an example application that displays the ground station's battery voltage and estimated remaining run time. In short, this is how it works. The main battery voltage is measured via pin A2 on the Minim board (labelled "VBAT1"). The application retrieves this value using a "GET_SENSOR" request and shows it along with the estimated remaining runtime using a "P_RAW" / "P_WINDOW" request. The remaining runtime is a predicted value based on the voltage drop over time. So the external device (e.g. a smart-phone) polls the measured voltage periodically and tries to pinpoint the current value on the discharge curve. We use a characteristic lipo discharge voltage curve for small fixed loads. The value needs some time to get accurate.


TODO
----
- Get rid of Arduino.
- Put more static data into PROGMEM.
- Automatically clear OSD texts, configurable.


Other info
----------
Max manual: https://datasheets.maximintegrated.com/en/ds/MAX7456.pdf  
Avr manual: http://www.cs.ou.edu/~fagg/classes/general/atmel/avr-libc-user-manual-1.7.1.pdf
